def group_recommend(group_users,places):
    results=[]

    for place in places:
        total_score=0
        for user in group_users:
            total_score+=check_score(user,place["tags"])

            results.append({
            "place": place["name"],
            "score": total_score
        })
    results.sort(key=lambda x: x["score"], reverse=True)
    return results[:3]





import json



def load_dataset(path="data/dataset.json"):
    """Loads dataset.json which contains a list of place dictionaries."""
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)   # MUST be a JSON array

popularity_map = {
    "Offbeat": 1,
    "Medium": 2,
    "High": 3
}

def group_recommend(group_users, places, top_n=10):
    """
    group_users: list of lists e.g. [["beach","food"], ["mountains"]]
    places: list of dicts with "place" and "tags" fields
    returns: top_n places sorted by score
    """
    user_sets = [set(u) for u in group_users]

    results = []
    for place in places:
        place_tags = set(place.get("tags", []))

        # tag match score
        tag_score = sum(len(u & place_tags) for u in user_sets)

        # popularity boost
        pop_score = popularity_map.get(place.get("popularity", "Offbeat"), 1)

        final_score = tag_score + pop_score

        results.append({
            "place": place["place"],
            "state": place["state"],
            "score": final_score
        })

    # sort by score DESC
    results.sort(key=lambda x: x["score"], reverse=True)
    return results[:top_n]


def match_interests(user_interests, place_tags):
    """Score based on intersection of user interests & place tags."""
    return len(set(user_interests) & set(place_tags))


def match_traveller_type(user_type, best_for_list):
    """Return 1 if traveller type is supported, else 0."""
    return 1 if user_type.lower() in [b.lower() for b in best_for_list] else 0


def match_budget(user_budget, place_cost):
    """
    user_budget → low / mid / high
    place_cost → avg_cost_per_day (number)
    """
    if place_cost is None:
        return 0

    if user_budget == "low" and place_cost <= 1500:
        return 1
    if user_budget == "mid" and 1500 < place_cost <= 4000:
        return 1
    if user_budget == "high" and place_cost > 4000:
        return 1

    return 0


# ---------------------- FINAL COMBINED RECOMMENDER ----------------------

def travel_recommend(user_type, user_interests, user_budget, places, top_n=10):
    """
    Main recommender used in UI.
    """
    results = []

    for p in places:
        interest_score = match_interests(user_interests, p.get("tags", [])) * 3
        traveller_score = match_traveller_type(user_type, p.get("best_for", [])) * 2
        budget_score = match_budget(user_budget, p.get("avg_cost_per_day"),) * 1

        popularity_boost = popularity_map.get(p.get("popularity", "Offbeat"), 1)

        total = interest_score + traveller_score + budget_score + popularity_boost

        results.append({
            "place": p["place"],
            "state": p["state"],
            "score": total
        })

    results.sort(key=lambda x: x["score"], reverse=True)
    return results[:top_n]





------------------- server --------------------------------

from pathlib import Path
from flask import Flask, request, jsonify
from recommender.core import load_dataset, travel_recommend
import random
import time
app = Flask(__name__)

# ------------------ LOAD DATASET ------------------
def _dataset_path() -> str:
    return str(Path(__file__).resolve().parent.parent / "data" / "dataset.json")

places = load_dataset("data/dataset.json")

# ---------- IN-MEMORY GROUP STORAGE ----------
groups = {}
# structure:
# {
#   "TS-1234": {
#       "members": [
#          {"name": "...", "type": "...", "interests": [...], "budget": "..."},
#          {...}
#       ]
#   }
# }

# ------------------ CORS FIX ------------------
@app.after_request
def add_cors_headers(response):
    response.headers["Access-Control-Allow-Origin"] = "*"
    response.headers["Access-Control-Allow-Headers"] = "Content-Type"
    response.headers["Access-Control-Allow-Methods"] = "POST, GET, OPTIONS"
    return response


# ------------------ CREATE GROUP ------------------
@app.route("/create_group", methods=["GET"])
def create_group():
    gid = f"TS-{random.randint(1000, 9999)}"
    # Initialize 'results' as None and 'is_calculating' as False
    groups[gid] = {
        "members": [], 
        "results": None, 
        "is_calculating": False
    }
    return jsonify({"group_id": gid})

# ---------- JOIN GROUP ----------
@app.route("/join_group", methods=["POST"])
def join_group():
    data = request.json

    group_id = data.get("group_id")
    if not group_id or group_id not in groups:
        return jsonify({"error": "Invalid Group ID"}), 400

    user_name = data.get("user_name", "Anonymous")
    
    # Check if user already exists in group (prevent duplicates)
    existing_members = groups[group_id]["members"]
    for i, member in enumerate(existing_members):
        if member.get("name") == user_name:
            # User already in group, UPDATE their preferences
            existing_members[i] = {
                "name": user_name,
                "type": data.get("user_type"),
                "interests": data.get("user_interests"),
                "budget": data.get("user_budget")
            }
            return jsonify({
                "success": True,
                "members": existing_members,
                "updated": True
            })
    
    # Add new user to group
    user = {
        "name": user_name,
        "type": data.get("user_type"),
        "interests": data.get("user_interests"),
        "budget": data.get("user_budget")
    }

    groups[group_id]["members"].append(user)

    return jsonify({
        "success": True,
        "members": groups[group_id]["members"],
        "already_joined": False
    })


# ---------- VERIFY GROUP (CHECK IF EXISTS) ----------
@app.route("/verify_group", methods=["POST"])
def verify_group():
    data = request.json
    group_id = data.get("group_id")

    if not group_id or group_id not in groups:
        return jsonify({"success": False, "error": "Invalid Group ID"}), 400

    return jsonify({
        "success": True,
        "group_id": group_id,
        "member_count": len(groups[group_id]["members"])
    })


# ---------- GET GROUP MEMBERS ----------
@app.route("/get_group_members", methods=["POST"])
def get_group_members():
    data = request.json
    group_id = data.get("group_id")

    if not group_id or group_id not in groups:
        return jsonify({"error": "Invalid Group ID"}), 400

    group_data = groups[group_id]
    
    # Return members AND the results (if they exist)
    return jsonify({
        "success": True,
        "members": group_data["members"],
        "trip_results": group_data.get("results", []) 
    })


# ---------- GENERATE GROUP TRIP ----------
# ---------- IN server.py ----------

import time  # <--- Add this at the top of server.py

@app.route("/generate_group_trip", methods=["POST"])
def generate_group_trip():
    data = request.json
    group_id = data.get("group_id")

    if not group_id or group_id not in groups:
        return jsonify({"error": "Invalid Group ID"}), 400

    group = groups[group_id]

    # 1. CHECK: If results exist, return them immediately
    if group.get("results"):
        return jsonify(group["results"])

    # 2. LOCK: If someone else is ALREADY calculating, wait for them
    if group.get("is_calculating"):
        # Wait up to 10 seconds for the other thread to finish
        attempts = 0
        while group.get("is_calculating") and attempts < 20:
            time.sleep(0.5)
            attempts += 1
            # If results appear while waiting, grab them!
            if group.get("results"):
                return jsonify(group["results"])
        
        # If still stuck after 10s, proceed (failsafe)

    # 3. MARK START: Lock the group
    group["is_calculating"] = True

    try:
        members = group["members"]
        
        # Combine interests
        group_interests = [m["interests"] for m in members]

        # Pick majority budget
        budgets = [m["budget"] for m in members]
        group_budget = max(set(budgets), key=budgets.count) if budgets else "mid"

        # Calculate
        results = travel_recommend(
            user_type="friends",
            user_interests=group_interests,
            user_budget=group_budget,
            places=places,
            top_n=6
        )

        # 4. SAVE RESULTS
        group["results"] = results

    finally:
        # 5. UNLOCK: Always release the lock, even if code crashes
        group["is_calculating"] = False

    return jsonify(results)
# ------------------ SINGLE-USER RECOMMEND ------------------
@app.route("/recommend", methods=["POST"])
def recommend():
    data = request.json

    user_type = data.get("user_type")
    user_interests = data.get("user_interests")
    user_budget = data.get("user_budget")

    results = travel_recommend(
        user_type=user_type,
        user_interests=user_interests,
        user_budget=user_budget,
        places=places,
        top_n=6
    )

    return jsonify(results)


# ------------------ HEALTH CHECK ------------------
@app.route("/health", methods=["GET"])
def health():
    return {"status": "ok", "items_loaded": len(places), "groups": len(groups)}


if __name__ == "__main__":
    app.run(debug=True)


ARLI_API_KEY="5bb3d6c8-c657-40c7-9ff5-0a8d2646bf45"
PROJECT_ID="pivotal-leaf-471506-p3"
